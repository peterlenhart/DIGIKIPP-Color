<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DigiKipp – Schauen & Merken</title>

  <style>
    :root{
      --cols: 8;
      --cell: 142px;
      --grid-alpha: 0.18;

      --violett: rgb(164, 27, 133);
      --blau:    rgb(0, 107, 179);
      --gruen:   rgb(0, 166, 82);
      --orange:  rgb(249, 150, 30);

      --colorSize: 126px;

      --bg-off-x: 4px;
      --bg-off-y: 5px;

      --scale: 1;
      --uiscale: 1;
      --gridW: calc(var(--cols) * var(--cell));
      --gridH: 100vh;

      --ui-panel-bg: #4a2418;
      --ui-text: #ead7be;
      --btn-bg: #ead7be;
      --btn-text: #2a160c;
      --btn-border: rgba(0,0,0,0.35);
      --slot-border: rgba(0,0,0,0.55);
      --slot-border-w: 4px;

      /* Würfel-Farben */
      --cube-wood-base: #d7c2a4;
      --cube-wood-deep: #c9b08f;
      --cube-wood-warm: rgba(155, 70, 110, 0.10);
      --cube-wood-gold: rgba(249, 150, 30, 0.10);
      --w1-innerframe: rgba(122, 74, 52, 1);
      --slot-fill: #ead7be;

      --rotSign: 1;
      --rot: 0deg;

      /* Header-Skalierung für X und P00/80 (75%) */
      --headerScale: 0.75;

      /* ===========
         CLIP: Schatten darf NUR im Innenraum 2B–7G sichtbar sein
         Zeile 1 = Farbfeldzeile
         Innenraum beginnt bei 2B und endet bei 7G
         =========== */
      --clipTop:    calc((2 - 1) * var(--cell)); /* ab Zeile 2 */
      --clipLeft:   calc((2 - 1) * var(--cell)); /* ab Spalte B (=2) */
      --clipRight:  calc((8 - 7) * var(--cell)); /* rechts bleibt 1 Spalte (H) */
      --clipBottom: calc(var(--gridH) - (7 * var(--cell))); /* unten ab Zeile 8 */
    }

    html, body{
      height: 100%;
      margin: 0;
      overflow: hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      touch-action: manipulation;
    }

    body{
      background:
        radial-gradient(120% 90% at 50% 10%, rgba(255,255,255,0.18), rgba(0,0,0,0.12) 55%, rgba(0,0,0,0.22) 100%),
        repeating-linear-gradient(
          90deg,
          rgba(140,105,70,0.10) 0px,
          rgba(140,105,70,0.10) 10px,
          rgba(230,205,165,0.10) 10px,
          rgba(230,205,165,0.10) 22px
        ),
        linear-gradient(180deg, #d9c3a2, #cdb28f);
      display: flex;
      justify-content: center;
      align-items: flex-start;
    }

    .stage{
      width: 100vw;
      height: 100vh;
      position: relative;
      overflow: hidden;
    }

    .layout{
      position: absolute;
      left: 50%;
      top: 0;
      width: var(--gridW);
      height: var(--gridH);
      transform-origin: top center;
      transform: translateX(-50%) scale(var(--scale));
    }

    /* Z-INDEX: 0 - Box Hintergrund PNG */
    .bgPNG{
      position:absolute;
      left: 0;
      top: 0;
      width: var(--gridW);
      height: var(--gridH);
      background-image: url("Box_m_Hgr.png");
      background-repeat: no-repeat;
      background-size: 100% auto;
      background-position:
        calc(0px + var(--bg-off-x))
        calc(0px + var(--bg-off-y));
      pointer-events: none;
      z-index: 0;
    }

    /* Z-INDEX: 1 - Kugel (UNTER dem Würfel) */
    .ball{
      position: absolute;
      left: calc(4 * var(--cell));
      top: calc((4 + 2) * var(--cell));
      width: calc(var(--cell) * 0.55);
      height: calc(var(--cell) * 0.55);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      background:
        radial-gradient(circle at 30% 28%, rgba(255,255,255,0.55), rgba(255,255,255,0.0) 45%),
        radial-gradient(circle at 55% 60%, rgba(0,0,0,0.18), rgba(0,0,0,0.00) 55%),
        radial-gradient(circle at 50% 55%, #d6b996, #b88d63 70%);
      box-shadow: 0 5px 10px rgba(0,0,0,0.28);
      z-index: 1;
      pointer-events: none;
    }

    .colors{
      position:absolute;
      left: 0;
      top: 0;
      width: var(--gridW);
      height: var(--gridH);
      pointer-events: none;
      z-index: 1;
    }

    .colorSq{
      position:absolute;
      width: var(--colorSize);
      height: var(--colorSize);
      border-radius: 0;
    }
    .c-gruen   { background: var(--gruen); }
    .c-orange  { background: var(--orange); }
    .c-blau    { background: var(--blau); }
    .c-violett { background: var(--violett); }

    /* =========================================
       Z-INDEX: 2 - Würfel-Schatten (vollflächig)
       - dreht MIT dem Würfel (Pivot im Zentrum)
       - wird HART auf 2B–7G geclippt (kein Pixel nach außen)
       ========================================= */
    .cubeShadowLayer{
      position: absolute;
      left: 0;
      top: 0;
      width: var(--gridW);
      height: var(--gridH);
      z-index: 2;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.15s ease;

      --pivot-x: calc(4 * var(--cell));
      --pivot-y: calc((4 + 2) * var(--cell));

      transform:
        translate(var(--pivot-x), var(--pivot-y))
        rotate(var(--rot))
        translate(calc(-1 * var(--pivot-x)), calc(-1 * var(--pivot-y)));
      transform-origin: 0 0;
    }

    .cubeShadowLayer.visible{ opacity: 1; }

    .cubeShadowClip{
      position:absolute;
      inset:0;
      pointer-events:none;
      clip-path: inset(var(--clipTop) var(--clipRight) var(--clipBottom) var(--clipLeft));
    }

    .cubeShadowInner{
      position: absolute;
      left: calc(1 * var(--cell));
      top:  calc((1 + 2) * var(--cell));
      width: calc(3 * var(--cell));
      height: calc(3 * var(--cell));
      background: transparent;
      border-radius: 10px;
      box-shadow:
        18px 26px 34px rgba(0,0,0,0.36),
        26px 38px 54px rgba(0,0,0,0.26),
        34px 50px 78px rgba(0,0,0,0.18);
      filter: drop-shadow(0 0 0 rgba(0,0,0,0));
    }

    .grid{
      position:absolute;
      left: 0;
      top: 0;
      width: var(--gridW);
      height: var(--gridH);
      z-index: 2;
      pointer-events: none;
      background-image:
        repeating-linear-gradient(
          to right,
          rgba(255,255,255,var(--grid-alpha)) 0px,
          rgba(255,255,255,var(--grid-alpha)) 1px,
          rgba(255,255,255,0) 1px,
          rgba(255,255,255,0) var(--cell)
        ),
        repeating-linear-gradient(
          to bottom,
          rgba(255,255,255,var(--grid-alpha)) 0px,
          rgba(255,255,255,var(--grid-alpha)) 1px,
          rgba(255,255,255,0) 1px,
          rgba(255,255,255,0) var(--cell)
        );
    }

    /* Z-INDEX: 3 - Zwischenkipp-Schatten PNGs */
    .zwischenKippSchattenLayer{
      position: absolute;
      left: 0;
      top: 0;
      width: var(--gridW);
      height: var(--gridH);
      z-index: 3;
      pointer-events: none;
    }

    .zwischenKippSchatten{
      position: absolute;
      left: calc(1 * var(--cell));
      top: calc(3 * var(--cell));
      width: calc(6 * var(--cell));
      height: calc(6 * var(--cell));
      background-size: 100% 100%;
      background-repeat: no-repeat;
      background-position: 0 0;
      opacity: 0;
      transition: opacity 0.1s ease;
    }

    .zwischenKippSchatten.visible{ opacity: 1; }

    #shadowQ0{ background-image: url("SchattenZwischenKipp_Q0.png"); }
    #shadowQ1{ background-image: url("SchattenZwischenKipp_Q1.png"); }
    #shadowQ2{ background-image: url("SchattenZwischenKipp_Q2.png"); }
    #shadowQ3{ background-image: url("SchattenZwischenKipp_Q3.png"); }

    /* Z-INDEX: 4 - Würfel Groups */
    .wFaceGroup,
    .kipGroup{
      position: absolute;
      left: 0;
      top: 0;
      width: var(--gridW);
      height: var(--gridH);
      z-index: 4;
      pointer-events: none;

      --pivot-x: calc(4 * var(--cell));
      --pivot-y: calc((4 + 2) * var(--cell));

      transform:
        translate(var(--pivot-x), var(--pivot-y))
        rotate(var(--rot))
        translate(calc(-1 * var(--pivot-x)), calc(-1 * var(--pivot-y)));
      transform-origin: 0 0;
    }

    .cubeFace{
      position: absolute;
      left: calc(1 * var(--cell));
      top:  calc((1 + 2) * var(--cell));
      width: calc(3 * var(--cell));
      height: calc(3 * var(--cell));
      border-radius: 10px;
      overflow: hidden;
    }

    .w0Face{ z-index: 4; }
    .w1Face{ z-index: 5; }
    .w2Face{ z-index: 6; }
    .kipFace{ z-index: 7; }

    .fSlot{
      position:absolute;
      width: var(--cell);
      height: var(--cell);
      border: var(--slot-border-w) solid var(--slot-border);
      box-sizing: border-box;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 32px;
      font-weight: 600;
      color: #2a160c;
      background: var(--slot-fill);
    }

    .fSlot.top-left     { left:0; top:0; border-radius: 10px 0 0 0; }
    .fSlot.top-center   { left: var(--cell); top:0; }
    .fSlot.top-right    { left: calc(2 * var(--cell)); top:0; border-radius: 0 10px 0 0; }
    .fSlot.mid-left     { left:0; top: var(--cell); }
    .fSlot.mid-center   { left: var(--cell); top: var(--cell); }
    .fSlot.mid-right    { left: calc(2 * var(--cell)); top: var(--cell); }
    .fSlot.bot-left     { left:0; top: calc(2 * var(--cell)); border-radius: 0 0 0 10px; }
    .fSlot.bot-center   { left: var(--cell); top: calc(2 * var(--cell)); }
    .fSlot.bot-right    { left: calc(2 * var(--cell)); top: calc(2 * var(--cell)); border-radius: 0 0 10px 0; }

    .w0Face.cubeFace{ background: var(--cube-wood-base); }
    .w1Face.cubeFace{
      background:
        linear-gradient(135deg, transparent 48%, var(--w1-innerframe) 48%, var(--w1-innerframe) 52%, transparent 52%),
        var(--cube-wood-base);
    }
    .w2Face.cubeFace{ background: var(--cube-wood-deep); }
    .kipFace.cubeFace{
      background:
        radial-gradient(circle at 45% 40%, var(--cube-wood-warm), transparent 50%),
        radial-gradient(circle at 60% 65%, var(--cube-wood-gold), transparent 50%),
        var(--cube-wood-deep);
    }

    .kipFace .fSlot.mid-center{ background: transparent; border: none; }

    .targetNumber{
      pointer-events: none;
      z-index: 25;
      position: absolute;
      font-weight: 600;
      font-size: 46px;
      line-height: 1;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      font-variant-numeric: tabular-nums;
      text-shadow:
        0 2px 4px rgba(0,0,0,0.30),
        0 0 2px rgba(255,255,255,0.50);

      --pivot-x: calc(4 * var(--cell));
      --pivot-y: calc((4 + 2) * var(--cell));

      transform:
        translate(var(--pivot-x), var(--pivot-y))
        rotate(var(--rot))
        translate(calc(-1 * var(--pivot-x)), calc(-1 * var(--pivot-y)));
      transform-origin: 0 0;
    }

    /* Z-INDEX: 30 - UI-Elemente */
    .closeButton,
    .testBtn{
      position: absolute;
      width: 70px;
      height: 70px;
      border-radius: 50%;
      background: var(--btn-bg);
      border: 4px solid var(--btn-border);
      box-shadow: 0 4px 10px rgba(0,0,0,0.28);
      color: var(--btn-text);
      font-weight: 700;
      font-size: 56px;
      cursor: pointer;
      z-index: 30;
      pointer-events: auto;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      padding: 0;
    }
    .closeButton:active,
    .testBtn:active{
      transform: translate(-50%, -50%) scale(0.96);
    }

    .logoRow{
      position: absolute;
      left: 0;
      top: calc(1.0 * var(--cell));
      width: var(--gridW);
      height: var(--cell);
      pointer-events: none;
      z-index: 30;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .logoText{
      font-size: 52px;
      font-weight: 800;
      letter-spacing: 0.06em;
      color: var(--btn-text);
      text-shadow:
        0 6px 16px rgba(0,0,0,0.42),
        0 3px 8px rgba(0,0,0,0.32),
        0 1px 3px rgba(0,0,0,0.22);
      padding: 6px 14px;
      border-radius: 50px;
      background:
        linear-gradient(135deg,
          rgba(237,220,196, 0.9),
          rgba(226,208,180, 0.92) 40%,
          rgba(215,194,164, 0.90) 70%,
          rgba(205,178,144, 0.88));
      box-shadow:
        0 4px 14px rgba(0,0,0,0.28),
        inset 0 1px 2px rgba(255,255,255,0.30),
        inset 0 -1px 2px rgba(0,0,0,0.15);
      border: 2px solid rgba(255,255,255,0.20);
    }

    .scorePanel{
      position: absolute;
      top: calc(1.0 * var(--cell));
      right: calc(1 * var(--cell));
      width: auto;
      height: var(--cell);
      pointer-events: none;
      z-index: 30;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .scoreText{
      font-size: 42px;
      font-weight: 800;
      color: var(--btn-text);
      text-shadow:
        0 5px 14px rgba(0,0,0,0.38),
        0 3px 7px rgba(0,0,0,0.28),
        0 1px 3px rgba(0,0,0,0.18);
      padding: 6px 16px;
      border-radius: 50px;
      background:
        linear-gradient(135deg,
          rgba(237,220,196, 0.9),
          rgba(226,208,180, 0.92) 40%,
          rgba(215,194,164, 0.90) 70%,
          rgba(205,178,144, 0.88));
      box-shadow:
        0 4px 12px rgba(0,0,0,0.28),
        inset 0 1px 2px rgba(255,255,255,0.30),
        inset 0 -1px 2px rgba(0,0,0,0.15);
      border: 2px solid rgba(255,255,255,0.20);
      transform: scale(var(--headerScale));
      transform-origin: center right;
    }

    .kippAnzahlBtns{
      position: absolute;
      left: 0;
      top: calc(11 * var(--cell)); /* ÄNDERUNG: von 10 nach 11 */
      width: var(--gridW);
      height: var(--cell);
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: center;
      z-index: 30;
      pointer-events: none;
    }

    .kippAnzahlBtns button{
      pointer-events: auto;
    }

    .squareBtn{
      width: calc((var(--gridW) - 7 * 10px) / 6);
      height: calc(var(--cell) * 0.75);
      background: var(--btn-bg);
      border: 4px solid var(--btn-border);
      border-radius: 14px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.28);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: transform 0.08s ease, background 0.12s ease;
    }

    .squareBtn.selected{
      background: var(--orange);
    }

    .squareBtn:active{
      transform: scale(0.96);
    }

    .anzahlText{
      font-size: 56px;
      font-weight: 700;
      color: var(--btn-text);
      line-height: 1;
    }

    /* NEUE Rotation Buttons in Zeile 10 */
    .rotationBtns{
      position: absolute;
      left: 0;
      top: calc(10 * var(--cell));
      width: var(--gridW);
      height: var(--cell);
      display: flex;
      gap: 20px;
      align-items: center;
      justify-content: center;
      z-index: 30;
      pointer-events: none;
    }

    .rotationBtns button{
      pointer-events: auto;
    }

    .rotBtn{
      width: calc((var(--gridW) - 7 * 10px) / 6 * 2 + 20px); /* Doppelte Breite + 20px */
      height: calc(var(--cell) * 0.75);
      background: var(--btn-bg);
      border: 4px solid var(--btn-border);
      border-radius: 14px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.28);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: transform 0.08s ease;
      font-size: 48px;
      color: var(--btn-text);
    }

    .rotBtn:active{
      transform: scale(0.96);
    }

    .hidden{
      display: none !important;
    }

    .schauenView,
    .kippAnzahlView{
      position: absolute;
      inset:0;
      z-index: 20;
    }

    .bigButton{
      position: absolute;
      left: 50%;
      top: 70%;
      transform: translate(-50%, -50%);
      width: calc(var(--gridW) * 0.72);
      height: calc(var(--cell) * 1.2);
      background: var(--btn-bg);
      border: 4px solid var(--btn-border);
      border-radius: 30px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.32);
      color: var(--btn-text);
      font-weight: 700;
      font-size: 38px;
      cursor: pointer;
      z-index: 30;
      pointer-events: auto;
    }

    .bigButton:active{
      transform: translate(-50%, -50%) scale(0.98);
    }

    /* Modals */
    .overlay{
      position: fixed;
      inset:0;
      background: rgba(0,0,0,0.60);
      z-index: 9000;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .modal{
      background: var(--ui-panel-bg);
      color: var(--ui-text);
      border-radius: 20px;
      padding: 30px 40px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
      max-width: 90vw;
      text-align: center;
    }

    .modal h2{
      margin: 0 0 20px 0;
      font-size: 32px;
    }

    .modal p{
      margin: 0 0 30px 0;
      font-size: 20px;
    }

    .modalButtons{
      display: flex;
      gap: 20px;
      justify-content: center;
    }

    .modalBtn{
      padding: 12px 28px;
      border-radius: 10px;
      font-size: 20px;
      font-weight: 700;
      border: none;
      cursor: pointer;
      box-shadow: 0 3px 8px rgba(0,0,0,0.25);
    }

    .btnCancel{
      background: #888;
      color: #fff;
    }

    .btnConfirm{
      background: var(--orange);
      color: #fff;
    }

    .endOverlay .modal h2{
      margin-bottom: 30px;
    }

    .endOverlay .modalBtn{
      padding: 16px 40px;
      font-size: 24px;
    }
  </style>
</head>
<body>

  <div class="stage">
    <div class="layout">
      <!-- BG PNG -->
      <div class="bgPNG"></div>

      <!-- Kugel -->
      <div class="ball"></div>

      <!-- Farb-Quadrate -->
      <div class="colors" id="colors"></div>

      <!-- Würfel-Schatten -->
      <div class="cubeShadowLayer" id="cubeShadowLayer">
        <div class="cubeShadowClip">
          <div class="cubeShadowInner"></div>
        </div>
      </div>

      <!-- Zwischen-Kipp Schatten -->
      <div class="zwischenKippSchattenLayer">
        <div class="zwischenKippSchatten" id="shadowQ0"></div>
        <div class="zwischenKippSchatten" id="shadowQ1"></div>
        <div class="zwischenKippSchatten" id="shadowQ2"></div>
        <div class="zwischenKippSchatten" id="shadowQ3"></div>
      </div>

      <!-- W-Faces -->
      <div class="wFaceGroup" id="wFaceGroup">
        <div class="cubeFace w0Face" id="w0Face">
          <div class="fSlot top-left" data-faceslot="0-0"></div>
          <div class="fSlot top-center" data-faceslot="0-1"></div>
          <div class="fSlot top-right" data-faceslot="0-2"></div>
          <div class="fSlot mid-left" data-faceslot="0-3"></div>
          <div class="fSlot mid-center" data-faceslot="0-4"></div>
          <div class="fSlot mid-right" data-faceslot="0-5"></div>
          <div class="fSlot bot-left" data-faceslot="0-6"></div>
          <div class="fSlot bot-center" data-faceslot="0-7"></div>
          <div class="fSlot bot-right" data-faceslot="0-8"></div>
        </div>

        <div class="cubeFace w1Face" id="w1Face">
          <div class="fSlot top-left" data-faceslot="1-0"></div>
          <div class="fSlot top-center" data-faceslot="1-1"></div>
          <div class="fSlot top-right" data-faceslot="1-2"></div>
          <div class="fSlot mid-left" data-faceslot="1-3"></div>
          <div class="fSlot mid-center" data-faceslot="1-4"></div>
          <div class="fSlot mid-right" data-faceslot="1-5"></div>
          <div class="fSlot bot-left" data-faceslot="1-6"></div>
          <div class="fSlot bot-center" data-faceslot="1-7"></div>
          <div class="fSlot bot-right" data-faceslot="1-8"></div>
        </div>

        <div class="cubeFace w2Face" id="w2Face">
          <div class="fSlot top-left" data-faceslot="2-0"></div>
          <div class="fSlot top-center" data-faceslot="2-1"></div>
          <div class="fSlot top-right" data-faceslot="2-2"></div>
          <div class="fSlot mid-left" data-faceslot="2-3"></div>
          <div class="fSlot mid-center" data-faceslot="2-4"></div>
          <div class="fSlot mid-right" data-faceslot="2-5"></div>
          <div class="fSlot bot-left" data-faceslot="2-6"></div>
          <div class="fSlot bot-center" data-faceslot="2-7"></div>
          <div class="fSlot bot-right" data-faceslot="2-8"></div>
        </div>
      </div>

      <!-- Kip-Face -->
      <div class="kipGroup hidden" id="kipGroup">
        <div class="cubeFace kipFace" id="kipFace">
          <div class="fSlot top-left" data-faceslot="k-0"></div>
          <div class="fSlot top-center" data-faceslot="k-1"></div>
          <div class="fSlot top-right" data-faceslot="k-2"></div>
          <div class="fSlot mid-left" data-faceslot="k-3"></div>
          <div class="fSlot mid-center" data-faceslot="k-4"></div>
          <div class="fSlot mid-right" data-faceslot="k-5"></div>
          <div class="fSlot bot-left" data-faceslot="k-6"></div>
          <div class="fSlot bot-center" data-faceslot="k-7"></div>
          <div class="fSlot bot-right" data-faceslot="k-8"></div>
        </div>
      </div>

      <div class="grid"></div>
      <div class="targetNumberLayer" id="targetNumberLayer"></div>

      <!-- UI -->
      <div class="logoRow">
        <div class="logoText">DIGIKIPP</div>
      </div>

      <div class="scorePanel">
        <div class="scoreText" id="scoreText">P00/80</div>
      </div>

      <!-- SCHAUEN View -->
      <div class="schauenView" id="schauenView">
        <button class="closeButton" id="closeBtnSchauen">✕</button>
        <button class="bigButton" id="btnSchauen">SCHAUEN & MERKEN</button>
      </div>

      <!-- KIPP-ANZAHL View -->
      <div class="kippAnzahlView hidden" id="kippAnzahlView">
        <button class="closeButton" id="closeBtnAnzahl">✕</button>
        <div class="kippAnzahlBtns" id="kippAnzahlBtns"></div>
        
        <!-- NEUE ROTATION BUTTONS -->
        <div class="rotationBtns">
          <button class="rotBtn" id="btnCW" type="button">↻</button>
          <button class="rotBtn" id="btnCCW" type="button">↺</button>
        </div>
        
        <button class="testBtn hidden" id="testTargetBtn">T</button>
      </div>
    </div>
  </div>

  <!-- Close Modal -->
  <div class="overlay hidden" id="closeModal">
    <div class="modal">
      <h2>Spiel beenden?</h2>
      <p>Möchten Sie das Spiel wirklich beenden?</p>
      <div class="modalButtons">
        <button class="modalBtn btnCancel" id="modalCancel">Abbrechen</button>
        <button class="modalBtn btnConfirm" id="modalConfirm">Beenden</button>
      </div>
    </div>
  </div>

  <!-- End Overlay -->
  <div class="overlay hidden" id="endOverlay">
    <div class="modal">
      <h2>Spiel beendet</h2>
      <div class="modalButtons">
        <button class="modalBtn btnConfirm" id="endRestart">Neustart</button>
      </div>
    </div>
  </div>

  <script>
    const HEADER_ROW_OFFSET = 2;

    const colors = document.getElementById("colors");
    const wFaceGroup = document.getElementById("wFaceGroup");
    const kipGroup = document.getElementById("kipGroup");
    const cubeShadowLayer = document.getElementById("cubeShadowLayer");

    const schauenView = document.getElementById("schauenView");
    const kippAnzahlView = document.getElementById("kippAnzahlView");

    const closeBtnSchauen = document.getElementById("closeBtnSchauen");
    const closeBtnAnzahl = document.getElementById("closeBtnAnzahl");
    const btnSchauen = document.getElementById("btnSchauen");
    const kippAnzahlBtns = document.getElementById("kippAnzahlBtns");
    const testTargetBtn = document.getElementById("testTargetBtn");
    const targetNumberLayer = document.getElementById("targetNumberLayer");
    const scoreText = document.getElementById("scoreText");

    const closeModal = document.getElementById("closeModal");
    const modalCancel = document.getElementById("modalCancel");
    const modalConfirm = document.getElementById("modalConfirm");
    const endOverlay = document.getElementById("endOverlay");
    const endRestart = document.getElementById("endRestart");

    // NEUE ROTATION BUTTONS
    const btnCW = document.getElementById("btnCW");
    const btnCCW = document.getElementById("btnCCW");

    const shadowEls = [
      document.getElementById("shadowQ0"),
      document.getElementById("shadowQ1"),
      document.getElementById("shadowQ2"),
      document.getElementById("shadowQ3")
    ];

    const NUM_FACES = 3;
    const SLOTS_PER_FACE = 9;
    let cardDeck = [];
    let faceAssignments = Array.from({length: NUM_FACES}, () =>
      Array(SLOTS_PER_FACE).fill(null)
    );

    let rotIndex = 0;
    let faceIndex = 0;
    let currentView = "schauen";
    let selectedLevel = "brainy";
    let buttonState = "schauen";
    let selectedButtons = [];
    let currentTarget = null;
    let targetsGenerated = 0;
    let stopAtNextW = false;
    let previewToken = 0;
    let previewCancelled = false;

    const slotPositions = [
      {name:"top-left", classList:["top-left"]},
      {name:"top-center", classList:["top-center"]},
      {name:"top-right", classList:["top-right"]},
      {name:"mid-left", classList:["mid-left"]},
      {name:"mid-center", classList:["mid-center"]},
      {name:"mid-right", classList:["mid-right"]},
      {name:"bot-left", classList:["bot-left"]},
      {name:"bot-center", classList:["bot-center"]},
      {name:"bot-right", classList:["bot-right"]}
    ];

    function createCardDeck(){
      cardDeck = [];
      for(let n = 1; n <= 6; n++){
        for(let c of ["blau","gruen","orange","violett"]){
          cardDeck.push({num:n, color:c});
        }
      }
      cardDeck.push({num:null, color:null});
      cardDeck.push({num:null, color:null});
      cardDeck.push({num:null, color:null});
      shuffleDeck(cardDeck);
    }

    function shuffleDeck(arr){
      for(let i = arr.length - 1; i > 0; i--){
        const j = Math.floor(Math.random()*(i+1));
        [arr[i],arr[j]] = [arr[j],arr[i]];
      }
    }

    function reroll12_keepEmpty(){
      createCardDeck();
      for(let f=0; f<NUM_FACES; f++){
        for(let s=0; s<SLOTS_PER_FACE; s++){
          if(faceAssignments[f][s] && faceAssignments[f][s].num === null){
            continue;
          }
          faceAssignments[f][s] = null;
        }
      }
    }

    function ensureAssigned(fIdx){
      for(let s=0; s<SLOTS_PER_FACE; s++){
        if(faceAssignments[fIdx][s] === null){
          if(cardDeck.length === 0){
            faceAssignments[fIdx][s] = {num:null, color:null};
          } else {
            faceAssignments[fIdx][s] = cardDeck.pop();
          }
        }
      }
    }

    function renderW(){
      ensureAssigned(faceIndex);
      for(let f=0; f<NUM_FACES; f++){
        const wFace = document.getElementById(`w${f}Face`);
        if(!wFace) continue;
        for(let s=0; s<SLOTS_PER_FACE; s++){
          const slotEl = wFace.querySelector(`[data-faceslot="${f}-${s}"]`);
          if(!slotEl) continue;
          const card = faceAssignments[f][s];
          if(!card || card.num === null){
            slotEl.textContent = "";
            slotEl.style.background = "var(--slot-fill)";
          } else {
            slotEl.textContent = String(card.num);
            slotEl.style.background = `var(--${card.color})`;
          }
        }
      }
    }

    function renderKip(){
      ensureAssigned(faceIndex);
      const prevFIdx = (faceIndex === 0) ? (NUM_FACES - 1) : (faceIndex - 1);
      ensureAssigned(prevFIdx);

      const kipFace = document.getElementById("kipFace");
      if(!kipFace) return;

      for(let s=0; s<SLOTS_PER_FACE; s++){
        const slotEl = kipFace.querySelector(`[data-faceslot="k-${s}"]`);
        if(!slotEl) continue;

        const kCard = faceAssignments[faceIndex][s];
        if(!kCard || kCard.num === null){
          slotEl.textContent = "";
          slotEl.style.background = "var(--slot-fill)";
        } else {
          slotEl.textContent = String(kCard.num);
          slotEl.style.background = `var(--${kCard.color})`;
        }
      }
    }

    function showW(){
      wFaceGroup.classList.remove("hidden");
      kipGroup.classList.add("hidden");
      updateShadowVisibility();
    }

    function showKip(){
      wFaceGroup.classList.add("hidden");
      kipGroup.classList.remove("hidden");
      updateShadowVisibility();
    }

    function advanceFullCW(){
      rotIndex  = (rotIndex + 1) % 4;
      faceIndex = (faceIndex + 1) % NUM_FACES;
      setRotationSnap();
    }

    function setRotationSnap(){
      const deg = rotIndex * 90;
      document.documentElement.style.setProperty("--rot", deg + "deg");
    }

    function updateShadowVisibility(){
      const isWVisible = !wFaceGroup.classList.contains("hidden");
      const isKipVisible = !kipGroup.classList.contains("hidden");

      if(isWVisible){
        cubeShadowLayer.classList.add("visible");
      } else {
        cubeShadowLayer.classList.remove("visible");
    }

      shadowEls.forEach((el,i) => {
        if(isKipVisible && i === rotIndex){
          el.classList.add("visible");
        } else {
          el.classList.remove("visible");
        }
      });
    }

    function cancelPreview(){
      previewCancelled = true;
      previewToken++;
    }

    async function waitOrPause(phase, token){
      const ms = 750;
      const start = Date.now();
      while(Date.now() - start < ms){
        await new Promise(r => setTimeout(r, 50));
        if(previewCancelled || token !== previewToken){
          return false;
        }
      }
      return true;
    }

    async function runSetNumbersCycle(){
      previewCancelled = false;
      const myToken = ++previewToken;
      setSchauenText("SCHAUEN & MERKEN");
      setSchauenEnabled(false);

      for(let cyc=0; cyc<4; cyc++){
        showKip();
        renderKip();
        if(!await waitOrPause('kip', myToken)) return;

        advanceFullCW();
        showW();
        renderW();
        if(!await waitOrPause('w', myToken)) return;
      }

      buttonState = "spielen";
      setSchauenText("SPIELEN");
      setSchauenEnabled(true);
    }

    function setSchauenText(txt){
      btnSchauen.textContent = txt;
    }

    function setSchauenEnabled(enabled){
      btnSchauen.disabled = !enabled;
    }

    // ========== TARGET NUMBERS ==========
    function generateTargetNumberColor_Brainy(){
      if(targetsGenerated >= 40) return null;
      targetsGenerated++;

      const nums = [1,2,3,4,5,6];
      const cols = ["blau","gruen","orange","violett"];
      const n = nums[Math.floor(Math.random()*nums.length)];
      const c = cols[Math.floor(Math.random()*cols.length)];
      return {num:n, color:c};
    }

    function clearTargetNumbers(){
      targetNumberLayer.innerHTML = "";
    }

    function placeTargetNumbers(target){
      clearTargetNumbers();
      const {num, color} = target;

      for(let f=0; f<NUM_FACES; f++){
        ensureAssigned(f);
        for(let s=0; s<SLOTS_PER_FACE; s++){
          const card = faceAssignments[f][s];
          if(!card || card.num !== num || card.color !== color) continue;

          const wFace = document.getElementById(`w${f}Face`);
          if(!wFace) continue;
          const slotEl = wFace.querySelector(`[data-faceslot="${f}-${s}"]`);
          if(!slotEl) continue;

          const rect = slotEl.getBoundingClientRect();
          const layoutEl = document.querySelector(".layout");
          const layoutRect = layoutEl.getBoundingClientRect();
          const scale = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--scale")) || 1;

          const relX = (rect.left - layoutRect.left) / scale;
          const relY = (rect.top - layoutRect.top) / scale;
          const relW = rect.width / scale;
          const relH = rect.height / scale;

          const tDiv = document.createElement("div");
          tDiv.className = "targetNumber";
          tDiv.textContent = String(num);
          tDiv.style.color = `var(--${color})`;
          tDiv.style.left = (relX + relW/2) + "px";
          tDiv.style.top = (relY + relH/2) + "px";
          tDiv.style.transform = "translate(-50%, -50%)";

          targetNumberLayer.appendChild(tDiv);
        }
      }
    }

    // ========== COLOR SQUARES ==========
    const colorGrid = [
      ["orange","gruen","orange"],
      ["violett","blau","violett"],
      ["blau","violett","blau"],
      ["gruen","orange","gruen"]
    ];

    function rebuildColors(){
      colors.innerHTML = "";
      const cellPx = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--cell")) || 142;

      colorGrid.forEach((rowArr, rIdx) => {
        const visualRow = rIdx + 1 + HEADER_ROW_OFFSET;
        rowArr.forEach((c, cIdx) => {
          const colIndex = (cIdx === 0) ? 1 : (cIdx === 1) ? 4 : 8;
          const sq = document.createElement("div");
          sq.className = `colorSq c-${c}`;
          sq.style.left = ((colIndex - 1) * cellPx + 8) + "px";
          sq.style.top = ((visualRow - 1) * cellPx + 8) + "px";
          colors.appendChild(sq);
        });
      });
    }

    // ========== SIZING & POSITIONING ==========
    function setScaleToFitWidth(){
      const vw = window.innerWidth;
      const cell = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--cell")) || 142;
      const gridW = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--gridW")) || (8*cell);
      let scale = vw / gridW;
      if(scale > 1) scale = 1;
      document.documentElement.style.setProperty("--scale", scale);
      return { cell, scale };
    }

    function positionUI(){
      const cellPx = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--cell")) || 142;

      // Close links oben (Spalte A, Header) + 75% skaliert
      const closeCol = 1;
      const closeY = 1.0 * cellPx;
      const closeLeft = (closeCol - 1) * cellPx + cellPx / 2;
      const closeTop = closeY;

      const s = getComputedStyle(document.documentElement).getPropertyValue("--headerScale").trim() || 0.75;

      [closeBtnSchauen, closeBtnAnzahl].forEach(btn => {
        btn.style.left = closeLeft + "px";
        btn.style.top = closeTop + "px";
        btn.style.transform = `translate(-50%, -50%) scale(${s})`;
        btn.style.transformOrigin = "top left";
      });
    }

    function positionTestButton(cellPx){
      // ÄNDERUNG: T Button jetzt in Position 8H (row=8, col=8)
      const row = 8;
      const col = 8;
      const visualRow = row + HEADER_ROW_OFFSET;

      const left = (col - 1) * cellPx + cellPx/2;
      const top  = (visualRow - 1) * cellPx + cellPx/2;

      testTargetBtn.style.position = "absolute";
      testTargetBtn.style.left = left + "px";
      testTargetBtn.style.top = top + "px";
      testTargetBtn.style.transform = "translate(-50%, -50%)";
      testTargetBtn.style.zIndex = "30";
      testTargetBtn.style.pointerEvents = "auto";
    }

    function rebuild(){
      const { cell, scale } = setScaleToFitWidth();
      const vh = window.innerHeight;
      const effectiveLayoutHeight = vh / scale;
      const rows = Math.ceil(effectiveLayoutHeight / cell) + 1;
      const gridH = rows * cell;
      document.documentElement.style.setProperty("--gridH", gridH + "px");

      rebuildColors();
      positionUI();
      positionTestButton(cell);
      updateShadowVisibility();
    }

    function showSchauenView(){
      currentView = "schauen";
      schauenView.classList.remove("hidden");
      kippAnzahlView.classList.add("hidden");

      selectedLevel = "brainy";
      buttonState = "schauen";
      setSchauenText("SCHAUEN & MERKEN");
      setSchauenEnabled(true);

      targetsGenerated = 0;
      clearTargetNumbers();
      currentTarget = null;

      showW();
    }

    function showKippAnzahlView(){
      currentView = "anzahl";
      schauenView.classList.add("hidden");
      kippAnzahlView.classList.remove("hidden");

      buildKippAnzahlButtons();
      testTargetBtn.classList.remove("hidden");
      testTargetBtn.disabled = false;

      currentTarget = generateTargetNumberColor_Brainy();
      if(currentTarget) placeTargetNumbers(currentTarget);
    }

    function buildKippAnzahlButtons(){
      kippAnzahlBtns.innerHTML = "";
      kippAnzahlBtns.classList.add("compact");

      [1, 2, 3, 4, 5, 6].forEach(num => {
        const btn = document.createElement("button");
        btn.className = "squareBtn";
        btn.dataset.anzahl = num;
        btn.type = "button";
        btn.innerHTML = `<span class="anzahlText">${String(num)}</span>`;
        btn.addEventListener("click", () => handleAnzahlClick(num));
        kippAnzahlBtns.appendChild(btn);
      });
    }

    function setAnzahlButtonsLocked(locked){
      kippAnzahlBtns.querySelectorAll("button").forEach(b => b.disabled = locked);
      testTargetBtn.disabled = locked;
    }

    let runningKipp = false;

    async function runKippCyclesNoHit(count){
      if(runningKipp) return;
      runningKipp = true;

      const myToken = ++previewToken;

      for(let i = 0; i < count; i++){
        showKip();
        renderKip();
        if(!await waitOrPause('kip', myToken)){ runningKipp=false; return; }

        advanceFullCW();
        showW();
        renderW();
        if(!await waitOrPause('w', myToken)){ runningKipp=false; return; }
      }

      runningKipp = false;
    }

    function handleAnzahlClick(anzahl){
      if(selectedLevel !== "brainy") return;

      const clickedBtn = Array.from(kippAnzahlBtns.querySelectorAll("button"))
        .find(b => parseInt(b.dataset.anzahl) === anzahl);
      if(!clickedBtn) return;

      if(selectedButtons.includes(anzahl)){
        const totalKipps = selectedButtons.reduce((sum, val) => sum + val, 0);

        setAnzahlButtonsLocked(true);

        runKippCyclesNoHit(totalKipps).finally(() => {
          selectedButtons = [];
          kippAnzahlBtns.querySelectorAll("button").forEach(b => b.classList.remove("selected"));
          setAnzahlButtonsLocked(false);
        });
        return;
      }

      if(selectedButtons.length < 2){
        selectedButtons.push(anzahl);
        clickedBtn.classList.add("selected");

        if(selectedButtons.length === 2){
          const totalKipps = selectedButtons.reduce((sum, val) => sum + val, 0);

          setAnzahlButtonsLocked(true);

          runKippCyclesNoHit(totalKipps).finally(() => {
            selectedButtons = [];
            kippAnzahlBtns.querySelectorAll("button").forEach(b => b.classList.remove("selected"));
            setAnzahlButtonsLocked(false);
          });
        }
      }
    }

    testTargetBtn.addEventListener("click", () => {
      currentTarget = generateTargetNumberColor_Brainy();
      if(currentTarget) placeTargetNumbers(currentTarget);
    });

    btnSchauen.addEventListener("click", async () => {
      if(buttonState === "schauen"){
        await runSetNumbersCycle();
      } else if(buttonState === "spielen"){
        const isWVisible = !wFaceGroup.classList.contains("hidden");
        if(isWVisible){
          cancelPreview();
          showKippAnzahlView();
        } else {
          stopAtNextW = true;
        }
      }
    });

    // CW/CCW Buttons (vorerst ohne Funktion)
    btnCW.addEventListener("click", () => {
      // TODO: CW Rotation Funktion
      console.log("CW Button clicked");
    });

    btnCCW.addEventListener("click", () => {
      // TODO: CCW Rotation Funktion
      console.log("CCW Button clicked");
    });

    // ===== Beenden-Logik =====
    function showCloseModal(){
      cancelPreview();
      closeModal.classList.remove("hidden");
    }
    function hideCloseModal(){
      closeModal.classList.add("hidden");
    }

    function endGame(){
      cancelPreview();
      hideCloseModal();

      schauenView.classList.add("hidden");
      kippAnzahlView.classList.add("hidden");

      endOverlay.classList.remove("hidden");
    }

    closeBtnSchauen.addEventListener("click", showCloseModal);
    closeBtnAnzahl.addEventListener("click", showCloseModal);

    modalCancel.addEventListener("click", hideCloseModal);
    modalConfirm.addEventListener("click", endGame);

    closeModal.addEventListener("click", (e) => {
      if(e.target === closeModal) hideCloseModal();
    });

    endRestart.addEventListener("click", () => {
      location.reload();
    });

    // ===== Startlogik =====
    function fastInitAndEnterKippAnzahl(){
      cancelPreview();
      stopAtNextW = false;

      selectedLevel = "brainy";
      targetsGenerated = 0;
      cardDeck = [];

      clearTargetNumbers();
      currentTarget = null;

      reroll12_keepEmpty();
      ensureAssigned(0);
      ensureAssigned(1);
      ensureAssigned(2);

      rotIndex = 0;
      faceIndex = 0;
      setRotationSnap();

      for(let i=0;i<4;i++){
        rotIndex  = (rotIndex + 1) % 4;
        faceIndex = (faceIndex + 1) % 3;
      }

      rotIndex = 0;
      faceIndex = 1;
      setRotationSnap();

      showW();
      renderW();

      showKippAnzahlView();
    }

    window.addEventListener("load", () => {
      rebuild();
      fastInitAndEnterKippAnzahl();
      updateShadowVisibility();
    });

    window.addEventListener("resize", rebuild);

    document.addEventListener("touchmove", (e) => {
      const inRange = e.target && e.target.closest && e.target.closest('input[type="range"]');
      if(inRange) return;
      e.preventDefault();
    }, { passive:false });
  </script>
</body>
</html>
